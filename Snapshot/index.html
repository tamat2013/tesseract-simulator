<!doctype html>
<html lang="he">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>טסרקט 4D — סימולציה</title>
<style>
html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Arial}
#ui{position:fixed;left:12px;top:12px;z-index:5;backdrop-filter: blur(6px);background:rgba(255,255,255,0.95);padding:10px;border-radius:8px;max-width:360px}
label{display:block;font-size:13px;margin-top:6px}
input[type=range],input[type=number],input[type=color]{width:100%}
canvas{display:block}
button{margin-top:8px;padding:6px 10px;border-radius:6px;border:1px solid #aaa;background:#fff}
.row{display:flex;gap:6px}
.row > *{flex:1}
</style>
</head>
<body>
<div id="ui">
  <strong>סימולציית טסרקט 4D</strong>

  <label>מהירות סיבוב: <input id="globalSpeed" type="range" min="0" max="1" step="0.01" value="0.3"></label>
  <label>כיוון סיבוב: 
    <select id="rotationDir"><option value="1">חיובי</option><option value="-1">שלילי</option></select>
  </label>
  <label>גודל נקודות: <input id="size" type="range" min="1" max="8" step="1" value="3"></label>
  <label>צבע נקודות: <input id="pointColor" type="color" value="#ff0000"></label>
  <label>מרחק W->3D (dW): <input id="dW" type="range" min="0.5" max="10" step="0.1" value="2"></label>

  <button id="advancedBtn">אפשרויות מתקדמות ⬇</button>
  <div id="advancedOptions" style="display:none; margin-top:8px;">
    <label>סיבוב על מישורים:</label>
    <div class="row">
      <div>
        <label>XY <input id="rXY" type="range" min="-2" max="2" step="0.01" value="0"></label>
        <label>XZ <input id="rXZ" type="range" min="-2" max="2" step="0.01" value="0"></label>
        <label>YZ <input id="rYZ" type="range" min="-2" max="2" step="0.01" value="0"></label>
      </div>
      <div>
        <label>XW <input id="rXW" type="range" min="-2" max="2" step="0.01" value="0.6"></label>
        <label>YW <input id="rYW" type="range" min="-2" max="2" step="0.01" value="0.2"></label>
        <label>ZW <input id="rZW" type="range" min="-2" max="2" step="0.01" value="0"></label>
      </div>
    </div>
    <label>קנה מידה של הטסרקט <input id="cubeScale" type="range" min="0.5" max="3" step="0.1" value="1"></label>
  </div>

  <button id="saveBtn">שמור כקובץ HTML</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script>
// ---------------------- 4D utils ----------------------
function mat4Identity(){ return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]; }
function mat4Mul(A,B){ const C=new Array(16).fill(0); for(let i=0;i<4;i++) for(let j=0;j<4;j++) for(let k=0;k<4;k++) C[i*4+j]+=A[i*4+k]*B[k*4+j]; return C }
function applyMat4(m, v){ const [x,y,z,w]=v; return [ m[0]*x+m[1]*y+m[2]*z+m[3]*w, m[4]*x+m[5]*y+m[6]*z+m[7]*w, m[8]*x+m[9]*y+m[10]*z+m[11]*w, m[12]*x+m[13]*y+m[14]*z+m[15]*w ]; }
function rotation4(a,b,theta){ const M=mat4Identity(); M[a*4+a]=Math.cos(theta); M[b*4+b]=Math.cos(theta); M[a*4+b]=-Math.sin(theta); M[b*4+a]=Math.sin(theta); return M }

// ---------------------- tesseract ----------------------
function tesseractVertices(scale=1){ const verts=[]; for(let i=0;i<16;i++){ const x=(i&1)?1:-1; const y=(i&2)?1:-1; const z=(i&4)?1:-1; const w=(i&8)?1:-1; verts.push([x*scale,y*scale,z*scale,w*scale]); } return verts; }
function tesseractEdges(){ const edges=[]; for(let i=0;i<16;i++) for(let j=i+1;j<16;j++){ let diff=0; for(let b=0;b<4;b++) if(((i>>b)&1)!==((j>>b)&1)) diff++; if(diff===1) edges.push([i,j]); } return edges; }
function project4to3(v,dW){ const [x,y,z,w]=v; const k=1/(dW-w); return [x*k,y*k,z*k]; }

// ---------------------- three.js setup ----------------------
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 10000);
camera.position.set(0,0,6);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

// containers
let linesMesh = null;
const lineMat = new THREE.LineBasicMaterial({linewidth:1, color:0xffffff}); // קווים לבנים כברירת מחדל

// ---------------------- build geometry ----------------------
function updateRender(){
  if(linesMesh){ scene.remove(linesMesh); linesMesh.geometry.dispose(); linesMesh=null; }

  const positions = [];
  for(const v of state.verts){
    const p = applyMat4(state.rotationMatrix, v);
    const proj = project4to3(p, state.dW);
    positions.push(proj[0], proj[1], proj[2]);
  }

  const linePos = [];
  for(let i=0;i<16;i++) for(let j=i+1;j<16;j++){
    let diff=0; 
    for(let b=0;b<4;b++) if(((i>>b)&1)!==((j>>b)&1)) diff++;
    if(diff===1){
      const ai=i*3, bi=j*3;
      linePos.push(positions[ai+0],positions[ai+1],positions[ai+2],
                   positions[bi+0],positions[bi+1],positions[bi+2]);
    }
  }

  const geom = new THREE.BufferGeometry();
  geom.setAttribute('position', new THREE.Float32BufferAttribute(linePos,3));
  linesMesh = new THREE.LineSegments(geom,lineMat);
  scene.add(linesMesh);
}
  
}

// ---------------------- rotation ----------------------
function buildRotationMatrixFromSliders(t){
  const dir = parseFloat(document.getElementById('rotationDir').value);
  const rXY=parseFloat(document.getElementById('rXY').value)*t*dir;
  const rXZ=parseFloat(document.getElementById('rXZ').value)*t*dir;
  const rYZ=parseFloat(document.getElementById('rYZ').value)*t*dir;
  const rXW=parseFloat(document.getElementById('rXW').value)*t*dir;
  const rYW=parseFloat(document.getElementById('rYW').value)*t*dir;
  const rZW=parseFloat(document.getElementById('rZW').value)*t*dir;
  let R = mat4Identity();
  R = mat4Mul(R, rotation4(0,1,rXY));
  R = mat4Mul(R, rotation4(0,2,rXZ));
  R = mat4Mul(R, rotation4(1,2,rYZ));
  R = mat4Mul(R, rotation4(0,3,rXW));
  R = mat4Mul(R, rotation4(1,3,rYW));
  R = mat4Mul(R, rotation4(2,3,rZW));
  return R;
}

// ---------------------- animation ----------------------
let lastTime=performance.now();
function animate(time){
  const dt=(time-lastTime)/1000; lastTime=time;
  const gs=parseFloat(document.getElementById('globalSpeed').value);
  state.rotationMatrix = mat4Mul(buildRotationMatrixFromSliders(dt*gs), state.rotationMatrix);
  state.dW = parseFloat(document.getElementById('dW').value);
  state.scale = parseFloat(document.getElementById('cubeScale')?.value || 1);
  updateRender();
  renderer.render(scene,camera);
  requestAnimationFrame(animate);
}

// ---------------------- load tesseract ----------------------
function loadTesseract(){ const s=parseFloat(document.getElementById('cubeScale').value||1); state.verts = tesseractVertices(s); updateRender(); }
loadTesseract();

// ---------------------- UI wiring ----------------------
document.getElementById('size').addEventListener('input',()=>updateRender());
document.getElementById('pointColor').addEventListener('input',()=>updateRender());
document.getElementById('advancedBtn').addEventListener('click',()=>{
  const advDiv=document.getElementById('advancedOptions');
  if(advDiv.style.display==='none'){ advDiv.style.display='block'; document.getElementById('advancedBtn').textContent='אפשרויות מתקדמות ⬆'; }
  else { advDiv.style.display='none'; document.getElementById('advancedBtn').textContent='אפשרויות מתקדמות ⬇'; }
});
document.getElementById('cubeScale').addEventListener('input',()=>loadTesseract());
document.getElementById('saveBtn').addEventListener('click',()=>{
  const blob = new Blob([document.documentElement.outerHTML],{type:'text/html;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='4D_tesseract.html'; a.click(); URL.revokeObjectURL(url);
});

// ---------------------- simple orbit ----------------------
let isDown=false,startX=0,startY=0,angleX=0,angleY=0;
renderer.domElement.addEventListener('mousedown',e=>{isDown=true;startX=e.clientX;startY=e.clientY;});
window.addEventListener('mouseup',()=>isDown=false);
window.addEventListener('mousemove',e=>{
  if(!isDown) return;
  const dx=(e.clientX-startX)/200; const dy=(e.clientY-startY)/200;
  startX=e.clientX; startY=e.clientY;
  angleY+=dx; angleX+=dy;
  camera.position.x=Math.sin(angleY)*6;
  camera.position.y=Math.sin(angleX)*3;
  camera.position.z=Math.cos(angleY)*6;
  camera.lookAt(0,0,0);
});

requestAnimationFrame(animate);
</script>
</body>
</html>
